<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><!--JBuilder QuickDoc-->
<HEAD>
<TITLE>Class java.net.Socket</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY>

<H2>
<FONT SIZE="-1">java.net</FONT>
<BR>Class Socket</H2>
<DL>
<DT>public class <B>Socket</B>
</DL>
<DL><DD>This class implements client sockets (also called just "sockets"). A socket is an endpoint for communication between two machines. <p> The actual work of the socket is performed by an instance of the <code>SocketImpl</code> class. An application, by changing the socket factory that creates the socket implementation, can configure itself to create sockets appropriate to the local firewall.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Version:</B><DD>1.97, 01/23/03</DD>
<DT><B>Author:</B><DD>unascribed</DD>
<DT><B>Since:</B><DD>JDK1.0</DD>
<DT><B>See Also:</B><DD>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</DD>
<DD>java.net.SocketImpl</DD>
<DD>java.nio.channels.SocketChannel</DD>
</DL>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="created"></A>

<H3>created</H3>
<PRE>
private boolean <B>created</B></PRE>
<DL><DD>Various states of this socket.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="impl"></A>

<H3>impl</H3>
<PRE>
java.net.SocketImpl <B>impl</B></PRE>
<DL><DD>The implementation of this Socket.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="oldImpl"></A>

<H3>oldImpl</H3>
<PRE>
private boolean <B>oldImpl</B></PRE>
<DL><DD>Are we using an older SocketImpl?<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="factory"></A>

<H3>factory</H3>
<PRE>
private static java.net.SocketImplFactory <B>factory</B></PRE>
<DL><DD>The factory for all client sockets.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="Socket()"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>()</PRE>
<DL><DD>Creates an unconnected socket, with the system-default type of SocketImpl.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Since:</B><DD>JDK1.1</DD>
</DL>
<HR>

<A NAME="Socket(java.net.SocketImpl)"></A>

<H3>Socket</H3>
<PRE>
protected <B>Socket</B>(java.net.SocketImpl&nbsp;impl)</PRE>
<DL><DD>Creates an unconnected Socket with a user-specified SocketImpl. <P><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>impl</CODE> - an instance of a <B>SocketImpl</B> the subclass wishes to use on the Socket.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.lang.String&nbsp;host,
              int&nbsp;port)</PRE>
<DL><DD>Creates a stream socket and connects it to the specified port number on the named host. <p> If the specified host is <tt>null</tt> it is the equivalent of specifying the address as <tt><A HREF="java.net.InetAddress#getByName InetAddress.getByName">InetAddress.getByName</A>(null)</tt>. In other words, it is equivalent to specifying an address of the loopback interface. </p> <p> If the application has specified a server socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. <p> If there is a security manager, its <code>checkConnect</code> method is called with the host address and <code>port</code> as its arguments. This could result in a SecurityException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>host</CODE> - the host name, or <code>null</code> for the loopback address.</DD>
<DD><CODE>port</CODE> - the port number.</DD>
<DT><B>Throws:</B><DD><CODE>UnknownHostException</CODE> - if the IP address of the host could not be determined.</DD>
<DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>See Also:</B><DD>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</DD>
<DD>java.net.SocketImpl</DD>
<DD>java.net.SocketImplFactory#createSocketImpl()</DD>
<DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.net.InetAddress&nbsp;address,
              int&nbsp;port)</PRE>
<DL><DD>Creates a stream socket and connects it to the specified port number at the specified IP address. <p> If the application has specified a socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. <p> If there is a security manager, its <code>checkConnect</code> method is called with the host address and <code>port</code> as its arguments. This could result in a SecurityException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>address</CODE> - the IP address.</DD>
<DD><CODE>port</CODE> - the port number.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>See Also:</B><DD>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</DD>
<DD>java.net.SocketImpl</DD>
<DD>java.net.SocketImplFactory#createSocketImpl()</DD>
<DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, java.net.InetAddress, int)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.lang.String&nbsp;host,
              int&nbsp;port,
              java.net.InetAddress&nbsp;localAddr,
              int&nbsp;localPort)</PRE>
<DL><DD>Creates a socket and connects it to the specified remote host on the specified remote port. The Socket will also bind() to the local address and port supplied. <p> If the specified host is <tt>null</tt> it is the equivalent of specifying the address as <tt><A HREF="java.net.InetAddress#getByName InetAddress.getByName">InetAddress.getByName</A>(null)</tt>. In other words, it is equivalent to specifying an address of the loopback interface. </p> <p> If there is a security manager, its <code>checkConnect</code> method is called with the host address and <code>port</code> as its arguments. This could result in a SecurityException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>host</CODE> - the name of the remote host, or <code>null</code> for the loopback address.</DD>
<DD><CODE>port</CODE> - the remote port</DD>
<DD><CODE>localAddr</CODE> - the local address the socket is bound to</DD>
<DD><CODE>localPort</CODE> - the local port the socket is bound to</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, java.net.InetAddress, int)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.net.InetAddress&nbsp;address,
              int&nbsp;port,
              java.net.InetAddress&nbsp;localAddr,
              int&nbsp;localPort)</PRE>
<DL><DD>Creates a socket and connects it to the specified remote address on the specified remote port. The Socket will also bind() to the local address and port supplied. <p> If there is a security manager, its <code>checkConnect</code> method is called with the host address and <code>port</code> as its arguments. This could result in a SecurityException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>address</CODE> - the remote address</DD>
<DD><CODE>port</CODE> - the remote port</DD>
<DD><CODE>localAddr</CODE> - the local address the socket is bound to</DD>
<DD><CODE>localPort</CODE> - the local port the socket is bound to</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, boolean)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.lang.String&nbsp;host,
              int&nbsp;port,
              boolean&nbsp;stream)</PRE>
<DL><DD><B>Deprecated.</B>&nbsp;<I> Use DatagramSocket instead for UDP transport.</I></DD>
<DD>Creates a stream socket and connects it to the specified port number on the named host. <p> If the specified host is <tt>null</tt> it is the equivalent of specifying the address as <tt><A HREF="java.net.InetAddress#getByName InetAddress.getByName">InetAddress.getByName</A>(null)</tt>. In other words, it is equivalent to specifying an address of the loopback interface. </p> <p> If the stream argument is <code>true</code>, this creates a stream socket. If the stream argument is <code>false</code>, it creates a datagram socket. <p> If the application has specified a server socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. <p> If there is a security manager, its <code>checkConnect</code> method is called with the host address and <code>port</code> as its arguments. This could result in a SecurityException. <p> If a UDP socket is used, TCP/IP related socket options will not apply.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>host</CODE> - the host name, or <code>null</code> for the loopback address.</DD>
<DD><CODE>port</CODE> - the port number.</DD>
<DD><CODE>stream</CODE> - a <code>boolean</code> indicating whether this is a stream socket or a datagram socket.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>See Also:</B><DD>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</DD>
<DD>java.net.SocketImpl</DD>
<DD>java.net.SocketImplFactory#createSocketImpl()</DD>
<DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, boolean)"></A>

<H3>Socket</H3>
<PRE>
public <B>Socket</B>(java.net.InetAddress&nbsp;host,
              int&nbsp;port,
              boolean&nbsp;stream)</PRE>
<DL><DD><B>Deprecated.</B>&nbsp;<I> Use DatagramSocket instead for UDP transport.</I></DD>
<DD>Creates a socket and connects it to the specified port number at the specified IP address. <p> If the stream argument is <code>true</code>, this creates a stream socket. If the stream argument is <code>false</code>, it creates a datagram socket. <p> If the application has specified a server socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. <p>If there is a security manager, its <code>checkConnect</code> method is called with <code>host.getHostAddress()</code> and <code>port</code> as its arguments. This could result in a SecurityException. <p> If UDP socket is used, TCP/IP related socket options will not apply.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>host</CODE> - the IP address.</DD>
<DD><CODE>port</CODE> - the port number.</DD>
<DD><CODE>stream</CODE> - if <code>true</code>, create a stream socket; otherwise, create a datagram socket.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the socket.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkConnect</code> method doesn't allow the operation.</DD>
<DT><B>See Also:</B><DD>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</DD>
<DD>java.net.SocketImpl</DD>
<DD>java.net.SocketImplFactory#createSocketImpl()</DD>
<DD>SecurityManager#checkConnect</DD>
</DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="createImpl(boolean)"></A>

<H3>createImpl</H3>
<PRE>
void <B>createImpl</B>(boolean&nbsp;stream)</PRE>
<DL><DD>Creates the socket implementation.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>stream</CODE> - a <code>boolean</code> value : <code>true</code> for a TCP socket, <code>false</code> for UDP.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if creation fails</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="setImpl()"></A>

<H3>setImpl</H3>
<PRE>
void <B>setImpl</B>()</PRE>
<DL><DD>Sets impl to the system-default type of SocketImpl.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="getImpl()"></A>

<H3>getImpl</H3>
<PRE>
java.net.SocketImpl <B>getImpl</B>()</PRE>
<DL><DD>Get the <code>SocketImpl</code> attached to this socket, creating it if necessary.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>SocketImpl</code> attached to that ServerSocket.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if creation fails</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress)"></A>

<H3>connect</H3>
<PRE>
public void <B>connect</B>(java.net.SocketAddress&nbsp;endpoint)</PRE>
<DL><DD>Connects this socket to the server.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>endpoint</CODE> - the <code>SocketAddress</code></DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an error occurs during the connection</DD>
<DD><CODE>java.nio.channels.IllegalBlockingModeException</CODE> - if this socket has an associated channel, and the channel is in non-blocking mode</DD>
<DD><CODE>IllegalArgumentException</CODE> - if endpoint is null or is a SocketAddress subclass not supported by this socket</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress, int)"></A>

<H3>connect</H3>
<PRE>
public void <B>connect</B>(java.net.SocketAddress&nbsp;endpoint,
                    int&nbsp;timeout)</PRE>
<DL><DD>Connects this socket to the server with a specified timeout value. A timeout of zero is interpreted as an infinite timeout. The connection will then block until established or an error occurs.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>endpoint</CODE> - the <code>SocketAddress</code></DD>
<DD><CODE>timeout</CODE> - the timeout value to be used in milliseconds.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an error occurs during the connection</DD>
<DD><CODE>SocketTimeoutException</CODE> - if timeout expires before connecting</DD>
<DD><CODE>java.nio.channels.IllegalBlockingModeException</CODE> - if this socket has an associated channel, and the channel is in non-blocking mode</DD>
<DD><CODE>IllegalArgumentException</CODE> - if endpoint is null or is a SocketAddress subclass not supported by this socket</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="bind(java.net.SocketAddress)"></A>

<H3>bind</H3>
<PRE>
public void <B>bind</B>(java.net.SocketAddress&nbsp;bindpoint)</PRE>
<DL><DD>Binds the socket to a local address. <P> If the address is <code>null</code>, then the system will pick up an ephemeral port and a valid local address to bind the socket.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>bindpoint</CODE> - the <code>SocketAddress</code> to bind to</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if the bind operation fails, or if the socket is already bound.</DD>
<DD><CODE>IllegalArgumentException</CODE> - if bindpoint is a SocketAddress subclass not supported by this socket</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#isBound</DD>
</DL>
<HR>

<A NAME="postAccept()"></A>

<H3>postAccept</H3>
<PRE>
final void <B>postAccept</B>()</PRE>
<DL><DD>set the flags after an accept() call.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="getInetAddress()"></A>

<H3>getInetAddress</H3>
<PRE>
public java.net.InetAddress <B>getInetAddress</B>()</PRE>
<DL><DD>Returns the address to which the socket is connected.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the remote IP address to which this socket is connected, or <code>null</code> if the socket is not connected.</DD>
</DL>
<HR>

<A NAME="getLocalAddress()"></A>

<H3>getLocalAddress</H3>
<PRE>
public java.net.InetAddress <B>getLocalAddress</B>()</PRE>
<DL><DD>Gets the local address to which the socket is bound.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the local address to which the socket is bound or <code>InetAddress.anyLocalAddress()</code> if the socket is not bound yet.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
</DL>
<HR>

<A NAME="getPort()"></A>

<H3>getPort</H3>
<PRE>
public int <B>getPort</B>()</PRE>
<DL><DD>Returns the remote port to which this socket is connected.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the remote port number to which this socket is connected, or 0 if the socket is not connected yet.</DD>
</DL>
<HR>

<A NAME="getLocalPort()"></A>

<H3>getLocalPort</H3>
<PRE>
public int <B>getLocalPort</B>()</PRE>
<DL><DD>Returns the local port to which this socket is bound.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the local port number to which this socket is bound or -1 if the socket is not bound yet.</DD>
</DL>
<HR>

<A NAME="getRemoteSocketAddress()"></A>

<H3>getRemoteSocketAddress</H3>
<PRE>
public java.net.SocketAddress <B>getRemoteSocketAddress</B>()</PRE>
<DL><DD>Returns the address of the endpoint this socket is connected to, or <code>null</code> if it is unconnected.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>SocketAddress</code> reprensenting the remote endpoint of this socket, or <code>null</code> if it is not connected yet.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getInetAddress()</DD>
<DD>#getPort()</DD>
<DD>#connect(SocketAddress, int)</DD>
<DD>#connect(SocketAddress)</DD>
</DL>
<HR>

<A NAME="getLocalSocketAddress()"></A>

<H3>getLocalSocketAddress</H3>
<PRE>
public java.net.SocketAddress <B>getLocalSocketAddress</B>()</PRE>
<DL><DD>Returns the address of the endpoint this socket is bound to, or <code>null</code> if it is not bound yet.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>SocketAddress</code> representing the local endpoint of this socket, or <code>null</code> if it is not bound yet.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getLocalAddress()</DD>
<DD>#getLocalPort()</DD>
<DD>#bind(SocketAddress)</DD>
</DL>
<HR>

<A NAME="getChannel()"></A>

<H3>getChannel</H3>
<PRE>
public java.nio.channels.SocketChannel <B>getChannel</B>()</PRE>
<DL><DD>Returns the unique <A HREF="java.nio.channels.SocketChannel SocketChannel">SocketChannel</A> object associated with this socket, if any. <p> A socket will have a channel if, and only if, the channel itself was created via the <A HREF="java.nio.channels.SocketChannel#open SocketChannel.open">SocketChannel.open</A> or <A HREF="java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept">ServerSocketChannel.accept</A> methods.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the socket channel associated with this socket, or <tt>null</tt> if this socket was not created for a channel</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="getInputStream()"></A>

<H3>getInputStream</H3>
<PRE>
public java.io.InputStream <B>getInputStream</B>()</PRE>
<DL><DD>Returns an input stream for this socket. <p> If this socket has an associated channel then the resulting input stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the input stream's <tt>read</tt> operations will throw an <A HREF="java.nio.channels.IllegalBlockingModeException">java.nio.channels.IllegalBlockingModeException</A>. <p>Under abnormal conditions the underlying connection may be broken by the remote host or the network software (for example a connection reset in the case of TCP connections). When a broken connection is detected by the network software the following applies to the returned input stream :- <ul> <li><p>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using <A HREF="java.io.InputStream#read read">read</A>. <li><p>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by <A HREF="java.io.InputStream#read read">read</A>, then all subsequent calls to <A HREF="java.io.InputStream#read read">read</A> will throw an <A HREF="java.io.IOException IOException">IOException</A>. <li><p>If there are no bytes buffered on the socket, and the socket has not been closed using <A HREF="#close close">close</A>, then <A HREF="java.io.InputStream#available available">available</A> will return <code>0</code>. </ul><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>an input stream for reading bytes from this socket.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the input stream, the socket is closed, the socket is not connected, or the socket input has been shutdown using <A HREF="#shutdownInput()">#shutdownInput()</A></DD>
</DL>
<HR>

<A NAME="getOutputStream()"></A>

<H3>getOutputStream</H3>
<PRE>
public java.io.OutputStream <B>getOutputStream</B>()</PRE>
<DL><DD>Returns an output stream for this socket. <p> If this socket has an associated channel then the resulting output stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the output stream's <tt>write</tt> operations will throw an <A HREF="java.nio.channels.IllegalBlockingModeException">java.nio.channels.IllegalBlockingModeException</A>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>an output stream for writing bytes to this socket.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when creating the output stream or if the socket is not connected.</DD>
</DL>
<HR>

<A NAME="setTcpNoDelay(boolean)"></A>

<H3>setTcpNoDelay</H3>
<PRE>
public void <B>setTcpNoDelay</B>(boolean&nbsp;on)</PRE>
<DL><DD>Enable/disable TCP_NODELAY (disable/enable Nagle's algorithm).<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>on</CODE> - <code>true</code> to enable TCP_NODELAY, <code>false</code> to disable.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>#getTcpNoDelay()</DD>
</DL>
<HR>

<A NAME="getTcpNoDelay()"></A>

<H3>getTcpNoDelay</H3>
<PRE>
public boolean <B>getTcpNoDelay</B>()</PRE>
<DL><DD>Tests if TCP_NODELAY is enabled.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>boolean</code> indicating whether or not TCP_NODELAY is enabled.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>#setTcpNoDelay(boolean)</DD>
</DL>
<HR>

<A NAME="setSoLinger(boolean, int)"></A>

<H3>setSoLinger</H3>
<PRE>
public void <B>setSoLinger</B>(boolean&nbsp;on,
                        int&nbsp;linger)</PRE>
<DL><DD>Enable/disable SO_LINGER with the specified linger time in seconds. The maximum timeout value is platform specific. The setting only affects socket close.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>on</CODE> - whether or not to linger on.</DD>
<DD><CODE>linger</CODE> - how long to linger for, if on is true.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DD><CODE>IllegalArgumentException</CODE> - if the linger value is negative.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>#getSoLinger()</DD>
</DL>
<HR>

<A NAME="getSoLinger()"></A>

<H3>getSoLinger</H3>
<PRE>
public int <B>getSoLinger</B>()</PRE>
<DL><DD>Returns setting for SO_LINGER. -1 returns implies that the option is disabled. The setting only affects socket close.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the setting for SO_LINGER.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>#setSoLinger(boolean, int)</DD>
</DL>
<HR>

<A NAME="sendUrgentData(int)"></A>

<H3>sendUrgentData</H3>
<PRE>
public void <B>sendUrgentData</B>(int&nbsp;data)</PRE>
<DL><DD>Send one byte of urgent data on the socket. The byte to be sent is the lowest eight bits of the data parameter. The urgent byte is sent after any preceding writes to the socket OutputStream and before any future writes to the OutputStream.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>data</CODE> - The byte of data to send</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if there is an error sending the data.</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="setOOBInline(boolean)"></A>

<H3>setOOBInline</H3>
<PRE>
public void <B>setOOBInline</B>(boolean&nbsp;on)</PRE>
<DL><DD>Enable/disable OOBINLINE (receipt of TCP urgent data) By default, this option is disabled and TCP urgent data received on a socket is silently discarded. If the user wishes to receive urgent data, then this option must be enabled. When enabled, urgent data is received inline with normal data. <p> Note, only limited support is provided for handling incoming urgent data. In particular, no notification of incoming urgent data is provided and there is no capability to distinguish between normal data and urgent data unless provided by a higher level protocol.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>on</CODE> - <code>true</code> to enable OOBINLINE, <code>false</code> to disable.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getOOBInline()</DD>
</DL>
<HR>

<A NAME="getOOBInline()"></A>

<H3>getOOBInline</H3>
<PRE>
public boolean <B>getOOBInline</B>()</PRE>
<DL><DD>Tests if OOBINLINE is enabled.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>boolean</code> indicating whether or not OOBINLINE is enabled.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setOOBInline(boolean)</DD>
</DL>
<HR>

<A NAME="setSoTimeout(int)"></A>

<H3>setSoTimeout</H3>
<PRE>
public synchronized void <B>setSoTimeout</B>(int&nbsp;timeout)</PRE>
<DL><DD>Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a read() call on the InputStream associated with this Socket will block for only this amount of time. If the timeout expires, a <B>java.net.SocketTimeoutException</B> is raised, though the Socket is still valid. The option <B>must</B> be enabled prior to entering the blocking operation to have effect. The timeout must be > 0. A timeout of zero is interpreted as an infinite timeout.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the specified timeout, in milliseconds.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK 1.1</DD>
<DT><B>See Also:</B><DD>#getSoTimeout()</DD>
</DL>
<HR>

<A NAME="getSoTimeout()"></A>

<H3>getSoTimeout</H3>
<PRE>
public synchronized int <B>getSoTimeout</B>()</PRE>
<DL><DD>Returns setting for SO_TIMEOUT. 0 returns implies that the option is disabled (i.e., timeout of infinity).<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the setting for SO_TIMEOUT</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>JDK1.1</DD>
<DT><B>See Also:</B><DD>#setSoTimeout(int)</DD>
</DL>
<HR>

<A NAME="setSendBufferSize(int)"></A>

<H3>setSendBufferSize</H3>
<PRE>
public synchronized void <B>setSendBufferSize</B>(int&nbsp;size)</PRE>
<DL><DD>Sets the SO_SNDBUF option to the specified value for this <tt>Socket</tt>. The SO_SNDBUF option is used by the platform's networking code as a hint for the size to set the underlying network I/O buffers. <p>Because SO_SNDBUF is a hint, applications that want to verify what size the buffers were set to should call <A HREF="#getSendBufferSize()">#getSendBufferSize()</A>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>size</CODE> - the size to which to set the send buffer size. This value must be greater than 0.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DD><CODE>IllegalArgumentException</CODE> - if the value is 0 or is negative.</DD>
<DT><B>Since:</B><DD>1.2</DD>
<DT><B>See Also:</B><DD>#getSendBufferSize()</DD>
</DL>
<HR>

<A NAME="getSendBufferSize()"></A>

<H3>getSendBufferSize</H3>
<PRE>
public synchronized int <B>getSendBufferSize</B>()</PRE>
<DL><DD>Get value of the SO_SNDBUF option for this <tt>Socket</tt>, that is the buffer size used by the platform for output on this <tt>Socket</tt>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the SO_SNDBUF option for this <tt>Socket</tt>.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.2</DD>
<DT><B>See Also:</B><DD>#setSendBufferSize(int)</DD>
</DL>
<HR>

<A NAME="setReceiveBufferSize(int)"></A>

<H3>setReceiveBufferSize</H3>
<PRE>
public synchronized void <B>setReceiveBufferSize</B>(int&nbsp;size)</PRE>
<DL><DD>Sets the SO_RCVBUF option to the specified value for this <tt>Socket</tt>. The SO_RCVBUF option is used by the platform's networking code as a hint for the size to set the underlying network I/O buffers. <p>Increasing the receive buffer size can increase the performance of network I/O for high-volume connection, while decreasing it can help reduce the backlog of incoming data. <p>Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call <A HREF="#getReceiveBufferSize()">#getReceiveBufferSize()</A>. <p>The value of SO_RCVBUF is also used to set the TCP receive window that is advertized to the remote peer. Generally, the window size can be modified at any time when a socket is connected. However, if a receive window larger than 64K is required then this must be requested <B>before</B> the socket is connected to the remote peer. There are two cases to be aware of:<p> <ol> <li>For sockets accepted from a ServerSocket, this must be done by calling <A HREF="ServerSocket#setReceiveBufferSize(int)">ServerSocket#setReceiveBufferSize(int)</A> before the ServerSocket is bound to a local address.<p></li> <li>For client sockets, setReceiveBufferSize() must be called before connecting the socket to its remote peer.<p></li></ol><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>size</CODE> - the size to which to set the receive buffer size. This value must be greater than 0.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if the value is 0 or is negative.</DD>
<DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.2</DD>
<DT><B>See Also:</B><DD>#getReceiveBufferSize()</DD>
<DD>ServerSocket#setReceiveBufferSize(int)</DD>
</DL>
<HR>

<A NAME="getReceiveBufferSize()"></A>

<H3>getReceiveBufferSize</H3>
<PRE>
public synchronized int <B>getReceiveBufferSize</B>()</PRE>
<DL><DD>Gets the value of the SO_RCVBUF option for this <tt>Socket</tt>, that is the buffer size used by the platform for input on this <tt>Socket</tt>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the SO_RCVBUF option for this <tt>Socket</tt>.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.2</DD>
<DT><B>See Also:</B><DD>#setReceiveBufferSize(int)</DD>
</DL>
<HR>

<A NAME="setKeepAlive(boolean)"></A>

<H3>setKeepAlive</H3>
<PRE>
public void <B>setKeepAlive</B>(boolean&nbsp;on)</PRE>
<DL><DD>Enable/disable SO_KEEPALIVE.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>on</CODE> - whether or not to have socket keep alive turned on.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.3</DD>
<DT><B>See Also:</B><DD>#getKeepAlive()</DD>
</DL>
<HR>

<A NAME="getKeepAlive()"></A>

<H3>getKeepAlive</H3>
<PRE>
public boolean <B>getKeepAlive</B>()</PRE>
<DL><DD>Tests if SO_KEEPALIVE is enabled.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>boolean</code> indicating whether or not SO_KEEPALIVE is enabled.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.3</DD>
<DT><B>See Also:</B><DD>#setKeepAlive(boolean)</DD>
</DL>
<HR>

<A NAME="setTrafficClass(int)"></A>

<H3>setTrafficClass</H3>
<PRE>
public void <B>setTrafficClass</B>(int&nbsp;tc)</PRE>
<DL><DD>Sets traffic class or type-of-service octet in the IP header for packets sent from this Socket. As the underlying network implementation may ignore this value applications should consider it a hint. <P> The tc <B>must</B> be in the range <code> 0 <= tc <=255</code> or an IllegalArgumentException will be thrown. <p>Notes: <p> for Internet Protocol v4 the value consists of an octet with precedence and TOS fields as detailed in RFC 1349. The TOS field is bitset created by bitwise-or'ing values such the following :- <p> <UL> <LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI> <LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI> <LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI> <LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI> </UL> The last low order bit is always ignored as this corresponds to the MBZ (must be zero) bit. <p> Setting bits in the precedence field may result in a SocketException indicating that the operation is not permitted. <p> for Internet Protocol v6 <code>tc</code> is the value that would be placed into the sin6_flowinfo field of the IP header.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>tc</CODE> - an <code>int</code> value for the bitset.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error setting the traffic class or type-of-service</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getTrafficClass</DD>
</DL>
<HR>

<A NAME="getTrafficClass()"></A>

<H3>getTrafficClass</H3>
<PRE>
public int <B>getTrafficClass</B>()</PRE>
<DL><DD>Gets traffic class or type-of-service in the IP header for packets sent from this Socket <p> As the underlying network implementation may ignore the traffic class or type-of-service set using <A HREF="#setTrafficClass()">#setTrafficClass()</A> this method may return a different value than was previously set using the <A HREF="#setTrafficClass()">#setTrafficClass()</A> method on this Socket.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the traffic class or type-of-service already set</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error obtaining the traffic class or type-of-service value.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setTrafficClass</DD>
</DL>
<HR>

<A NAME="setReuseAddress(boolean)"></A>

<H3>setReuseAddress</H3>
<PRE>
public void <B>setReuseAddress</B>(boolean&nbsp;on)</PRE>
<DL><DD>Enable/disable the SO_REUSEADDR socket option. <p> When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the <tt>TIME_WAIT</tt> state or <tt>2MSL</tt> wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required <tt>SocketAddress</tt> if there is a connection in the timeout state involving the socket address or port. <p> Enabling <tt>SO_REUSEADDR</tt> prior to binding the socket using <A HREF="#bind(SocketAddress)">#bind(SocketAddress)</A> allows the socket to be bound even though a previous connection is in a timeout state. <p> When a <tt>Socket</tt> is created the initial setting of <tt>SO_REUSEADDR</tt> is disabled. <p> The behaviour when <tt>SO_REUSEADDR</tt> is enabled or disabled after a socket is bound (See <A HREF="#isBound()">#isBound()</A>) is not defined.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>on</CODE> - whether to enable or disable the socket option</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if an error occurs enabling or disabling the <tt>SO_RESUEADDR</tt> socket option, or the socket is closed.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getReuseAddress()</DD>
<DD>#bind(SocketAddress)</DD>
<DD>#isClosed()</DD>
<DD>#isBound()</DD>
</DL>
<HR>

<A NAME="getReuseAddress()"></A>

<H3>getReuseAddress</H3>
<PRE>
public boolean <B>getReuseAddress</B>()</PRE>
<DL><DD>Tests if SO_REUSEADDR is enabled.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a <code>boolean</code> indicating whether or not SO_REUSEADDR is enabled.</DD>
<DT><B>Throws:</B><DD><CODE>SocketException</CODE> - if there is an error in the underlying protocol, such as a TCP error.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setReuseAddress(boolean)</DD>
</DL>
<HR>

<A NAME="close()"></A>

<H3>close</H3>
<PRE>
public synchronized void <B>close</B>()</PRE>
<DL><DD>Closes this socket. <p> Any thread currently blocked in an I/O operation upon this socket will throw a <A HREF="SocketException">SocketException</A>. <p> Once a socket has been closed, it is not available for further networking use (i.e. can't be reconnected or rebound). A new socket needs to be created. <p> If this socket has an associated channel then the channel is closed as well.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when closing this socket.</DD>
<DT><B>See Also:</B><DD>#isClosed</DD>
</DL>
<HR>

<A NAME="shutdownInput()"></A>

<H3>shutdownInput</H3>
<PRE>
public void <B>shutdownInput</B>()</PRE>
<DL><DD>Places the input stream for this socket at "end of stream". Any data sent to the input stream side of the socket is acknowledged and then silently discarded. <p> If you read from a socket input stream after invoking shutdownInput() on the socket, the stream will return EOF.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when shutting down this socket.</DD>
<DT><B>Since:</B><DD>1.3</DD>
<DT><B>See Also:</B><DD>java.net.Socket#shutdownOutput()</DD>
<DD>java.net.Socket#close()</DD>
<DD>java.net.Socket#setSoLinger(boolean, int)</DD>
<DD>#isInputShutdown</DD>
</DL>
<HR>

<A NAME="shutdownOutput()"></A>

<H3>shutdownOutput</H3>
<PRE>
public void <B>shutdownOutput</B>()</PRE>
<DL><DD>Disables the output stream for this socket. For a TCP socket, any previously written data will be sent followed by TCP's normal connection termination sequence. If you write to a socket output stream after invoking shutdownOutput() on the socket, the stream will throw an IOException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when shutting down this socket.</DD>
<DT><B>Since:</B><DD>1.3</DD>
<DT><B>See Also:</B><DD>java.net.Socket#shutdownInput()</DD>
<DD>java.net.Socket#close()</DD>
<DD>java.net.Socket#setSoLinger(boolean, int)</DD>
<DD>#isOutputShutdown</DD>
</DL>
<HR>

<A NAME="toString()"></A>

<H3>toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL><DD>Converts this socket to a <code>String</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a string representation of this socket.</DD>
</DL>
<HR>

<A NAME="isConnected()"></A>

<H3>isConnected</H3>
<PRE>
public boolean <B>isConnected</B>()</PRE>
<DL><DD>Returns the connection state of the socket.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if the socket successfuly connected to a server</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<A NAME="isBound()"></A>

<H3>isBound</H3>
<PRE>
public boolean <B>isBound</B>()</PRE>
<DL><DD>Returns the binding state of the socket.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if the socket successfuly bound to an address</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#bind</DD>
</DL>
<HR>

<A NAME="isClosed()"></A>

<H3>isClosed</H3>
<PRE>
public boolean <B>isClosed</B>()</PRE>
<DL><DD>Returns the closed state of the socket.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if the socket has been closed</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#close</DD>
</DL>
<HR>

<A NAME="isInputShutdown()"></A>

<H3>isInputShutdown</H3>
<PRE>
public boolean <B>isInputShutdown</B>()</PRE>
<DL><DD>Returns wether the read-half of the socket connection is closed.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if the input of the socket has been shutdown</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#shutdownInput</DD>
</DL>
<HR>

<A NAME="isOutputShutdown()"></A>

<H3>isOutputShutdown</H3>
<PRE>
public boolean <B>isOutputShutdown</B>()</PRE>
<DL><DD>Returns wether the write-half of the socket connection is closed.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if the output of the socket has been shutdown</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#shutdownOutput</DD>
</DL>
<HR>

<A NAME="setSocketImplFactory(java.net.SocketImplFactory)"></A>

<H3>setSocketImplFactory</H3>
<PRE>
public static synchronized void <B>setSocketImplFactory</B>(java.net.SocketImplFactory&nbsp;fac)</PRE>
<DL><DD>Sets the client socket implementation factory for the application. The factory can be specified only once. <p> When an application creates a new client socket, the socket implementation factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. <p>If there is a security manager, this method first calls the security manager's <code>checkSetFactory</code> method to ensure the operation is allowed. This could result in a SecurityException.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>fac</CODE> - the desired factory.</DD>
<DT><B>Throws:</B><DD><CODE>IOException</CODE> - if an I/O error occurs when setting the socket factory.</DD>
<DD><CODE>SocketException</CODE> - if the factory is already defined.</DD>
<DD><CODE>SecurityException</CODE> - if a security manager exists and its <code>checkSetFactory</code> method doesn't allow the operation.</DD>
<DT><B>See Also:</B><DD>java.net.SocketImplFactory#createSocketImpl()</DD>
<DD>SecurityManager#checkSetFactory</DD>
</DL>
<HR>

</BODY>
</HTML>